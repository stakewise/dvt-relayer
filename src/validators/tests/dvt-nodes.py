"""
Obol keystores layout is used.
"""
import asyncio
import json
import logging
from pathlib import Path
from typing import Sequence

import aiohttp
from aiohttp import ClientResponseError, ClientTimeout
from decouple import config
from eth_typing import BLSPubkey, BLSSignature, HexStr
from web3 import Web3

from src.common.setup_logging import setup_logging
from src.config import settings
from src.validators.tests.key_shares import reconstruct_shared_bls_public_key
from src.validators.tests.keystores.local import LocalKeystore

setup_logging()

logger = logging.getLogger(__name__)

relayer_endpoint = config('RELAYER_ENDPOINT')
relayer_timeout = config('RELAYER_TIMEOUT', cast=int, default=10)
relayer_poll_interval = config('RELAYER_POLL_INTERVAL', cast=int, default=1)
cluster_path = Path(config('CLUSTER_PATH'))
cluster_size = config('CLUSTER_SIZE', cast=int)


async def run_dvt_nodes():
    keystores = {}
    for node_index in range(cluster_size):
        keystore = await load_keystore(node_index)
        keystores[node_index] = keystore

    # Deposit data file generated by Obol has public keys shuffled which is confusing.
    # Cluster lock contains public keys where ordering matches to keystores.
    # Rely on cluster lock.
    cluster_lock = load_cluster_lock()
    public_keys = [
        HexStr(dv['distributed_public_key']) for dv in cluster_lock['distributed_validators']
    ]

    check_reconstruct_public_key(public_keys, keystores)

    for node_index, keystore in keystores.items():
        asyncio.create_task(poll_exits_and_push_signatures(public_keys, keystore, node_index))

    # Keep tasks running
    while True:
        await asyncio.sleep(0.1)


def check_reconstruct_public_key(
    public_keys: list[HexStr], keystores: dict[int, LocalKeystore]
) -> None:
    """
    Check validator public keys can be restored from key shares
    """
    for keyfile_index, pubkey in enumerate(public_keys):
        public_key_shares = {}

        # collect shares for given pubkey
        for node_index, keystore in keystores.items():
            # convert node indexes to share indexes
            share_index = node_index + 1

            pubkey_share = keystore.public_keys[keyfile_index]
            public_key_shares[share_index] = BLSPubkey(Web3.to_bytes(hexstr=pubkey_share))

        # reconstruct public key
        reconstructed_pubkey = reconstruct_shared_bls_public_key(public_key_shares)
        assert pubkey == Web3.to_hex(reconstructed_pubkey)


async def load_keystore(node_index: int) -> LocalKeystore:
    dir_path = cluster_path / f'node{node_index}/validator_keys'
    return await LocalKeystore.load(Path(dir_path))


def load_cluster_lock() -> dict:
    cluster_lock_path = cluster_path / 'node0/cluster-lock.json'
    return json.load(open(cluster_lock_path))


async def poll_exits_and_push_signatures(
    public_keys: Sequence[HexStr], keystore: LocalKeystore, node_index: int
) -> None:
    public_key_to_created_at: dict[HexStr, int] = dict()
    pub_key_to_share = dict(zip(public_keys, keystore.public_keys))

    async with aiohttp.ClientSession(timeout=ClientTimeout(relayer_timeout)) as session:
        while True:
            try:
                exits = await poll_exits(session)
            except (ClientResponseError, asyncio.TimeoutError):
                logger.exception('Failed to push exit signature')

            public_key_to_exit_signature: dict[HexStr, HexStr] = {}
            for exit in exits:
                public_key = exit['public_key']
                if public_key_to_created_at[public_key] >= exit['created_at']:
                    continue

                pub_key_share = pub_key_to_share[public_key]
                exit_signature = await keystore.get_exit_signature(
                    exit['validator_index'],
                    pub_key_share,
                    settings.network_config.SHAPELLA_FORK,
                    settings.network_config.GENESIS_VALIDATORS_ROOT,
                )
                public_key_to_exit_signature[public_key] = Web3.to_hex(exit_signature)

            if public_key_to_exit_signature:
                await push_exit_signature(session, public_key_to_exit_signature, node_index)
                for exit in exits:
                    public_key = exit['public_key']
                    public_key_to_created_at[public_key] = exit['created_at']

            await asyncio.sleep(relayer_poll_interval)


async def poll_exits(session):
    while True:
        res = await session.get(f'{relayer_endpoint}/exits')
        res.raise_for_status()
        jsn = await res.json()
        if exits := jsn['exits']:
            return exits
        await asyncio.sleep(1)


async def get_exit_signature(
    keystore: LocalKeystore, validator_index: int, public_key: HexStr
) -> BLSSignature:
    fork = settings.network_config.SHAPELLA_FORK
    genesis_validators_root = settings.network_config.GENESIS_VALIDATORS_ROOT

    return await keystore.get_exit_signature(
        validator_index, public_key, fork, genesis_validators_root
    )


async def push_exit_signature(
    session: aiohttp.ClientSession,
    public_key_to_exit_signature: dict[HexStr, HexStr],
    node_index: int,
) -> None:
    share_index = node_index + 1
    shares = []
    for public_key, exit_signature in public_key_to_exit_signature.items():
        shares.append(
            {
                'public_key': public_key,
                'exit_signature': exit_signature,
            }
        )
    jsn = {'share_index': share_index, 'shares': shares}
    logger.info('push exit signature for share_index %s', share_index)
    res = await session.post(f'{relayer_endpoint}/exit-signature', json=jsn)
    res.raise_for_status()


if __name__ == '__main__':
    logger.info('network %s', settings.network)
    asyncio.run(run_dvt_nodes())
