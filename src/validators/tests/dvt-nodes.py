"""
Obol keystores layout is used.
"""
import asyncio
import json
import logging
from pathlib import Path
from typing import Sequence

import aiohttp
from aiohttp import ClientTimeout
from decouple import config
from eth_typing import BLSPubkey, BLSSignature, HexStr
from web3 import Web3

from src.common.setup_logging import setup_logging
from src.config import settings
from src.validators.tests.key_shares import reconstruct_shared_bls_public_key
from src.validators.tests.keystores.local import LocalKeystore

setup_logging()

logger = logging.getLogger(__name__)

relayer_endpoint = config('RELAYER_ENDPOINT')
cluster_path = Path(config('CLUSTER_PATH'))
cluster_size = config('CLUSTER_SIZE', cast=int)


async def run_dvt_nodes():
    keystores = {}
    for node_index in range(cluster_size):
        keystore = await load_keystore(node_index)
        keystores[node_index] = keystore

    # Deposit data file generated by Obol has public keys shuffled which is confusing.
    # Cluster lock contains public keys where ordering matches to keystores.
    # Rely on cluster lock.
    cluster_lock = load_cluster_lock()
    public_keys = [
        HexStr(dv['distributed_public_key']) for dv in cluster_lock['distributed_validators']
    ]

    check_reconstruct_public_key(public_keys, keystores)

    for node_index, keystore in keystores.items():
        asyncio.create_task(poll_validators_and_push_signatures(public_keys, keystore, node_index))

    # Keep tasks running
    while True:
        await asyncio.sleep(0.1)


def check_reconstruct_public_key(
    public_keys: list[HexStr], keystores: dict[int, LocalKeystore]
) -> None:
    """
    Check validator public keys can be restored from key shares
    """
    for keyfile_index, pubkey in enumerate(public_keys):
        public_key_shares = {}

        # collect shares for given pubkey
        for node_index, keystore in keystores.items():
            # convert node indexes to share indexes
            share_index = node_index + 1

            pubkey_share = keystore.public_keys[keyfile_index]
            public_key_shares[share_index] = BLSPubkey(Web3.to_bytes(hexstr=pubkey_share))

        # reconstruct public key
        reconstructed_pubkey = reconstruct_shared_bls_public_key(public_key_shares)
        assert pubkey == Web3.to_hex(reconstructed_pubkey)


async def load_keystore(node_index: int) -> LocalKeystore:
    dir_path = cluster_path / f'node{node_index}/validator_keys'
    return await LocalKeystore.load(Path(dir_path))


def load_cluster_lock() -> dict:
    cluster_lock_path = cluster_path / 'node0/cluster-lock.json'
    return json.load(open(cluster_lock_path))


async def poll_validators_and_push_signatures(
    public_keys: Sequence[HexStr], keystore: LocalKeystore, node_index: int
) -> None:
    pushed_public_keys = set()
    pub_key_to_share = dict(zip(public_keys, keystore.public_keys))

    async with aiohttp.ClientSession(timeout=ClientTimeout(5)) as session:
        while True:
            try:
                pending_validators = await poll_pending_validators(session)
                for pv in pending_validators:
                    if pv['public_key'] in pushed_public_keys:
                        continue
                    pub_key_share = pub_key_to_share[pv['public_key']]
                    exit_signature = await get_exit_signature(
                        keystore, pv['validator_index'], pub_key_share
                    )
                    await push_signature(session, pv['public_key'], exit_signature, node_index)
                    pushed_public_keys.add(pv['public_key'])
            except Exception as e:
                logger.exception('')
                logger.error(repr(e))
            await asyncio.sleep(1)


async def poll_pending_validators(session):
    while True:
        res = await session.get(f'{relayer_endpoint}/validators')
        res.raise_for_status()
        jsn = await res.json()
        if pending_validators := jsn['pending_validators']:
            return pending_validators
        await asyncio.sleep(1)


async def get_exit_signature(
    keystore: LocalKeystore, validator_index: int, public_key: HexStr
) -> BLSSignature:
    fork = settings.network_config.SHAPELLA_FORK
    genesis_validators_root = settings.network_config.GENESIS_VALIDATORS_ROOT

    return await keystore.get_exit_signature(
        validator_index, public_key, fork, genesis_validators_root
    )


async def push_signature(
    session: aiohttp.ClientSession,
    public_key: HexStr,
    exit_signature: BLSSignature,
    node_index: int,
) -> None:
    share_index = node_index + 1
    jsn = {
        'public_key': public_key,
        'share_index': share_index,
        'signature': Web3.to_hex(exit_signature),
    }
    logger.info('push exit signature for share_index %s', share_index)
    res = await session.post(f'{relayer_endpoint}/exit-signature', json=jsn)
    res.raise_for_status()


if __name__ == '__main__':
    logger.info('network %s', settings.network)
    asyncio.run(run_dvt_nodes())
